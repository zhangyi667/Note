---
title: 学习导图 
tags: Java Framework
grammar_cjkRuby: true
---

# Java 基础

# Spring MVC
## Three ways to config Spring containers
* load beans in xml files
* load beans in java files
* auto-load system

## 注解
### @Component注解。
这个简单的注解表明该类会作为组件类,并告知Spring要为这个类创建bean。没有必要显式配置SgtPeppersbean,因为这个类使用了@Component注解,所以Spring会为你把事情处理妥当。

### @ComponentScan注解
这个注解能够在Spring中启用组件扫描。(如果没有其他配置的话,@ComponentScan默认会扫描与配置类相同的包。)Spring将会扫描这个包以及这个包下的所有子包,查找带有@Component注解的类并且
会在Spring中自动为其创建一个bean。之所以用这个注解，是因为这个注解默认不打开

### @ContextConfiguration(classes=SomeClass.classs)注解
Enables config loading in SomeClass, which is a java config.

### @Profile注解
Profile annotation is the feature that Spring provides for user to create certain beans according to environment.
In java config, you can use this annotation to say whether a bean belongs to a profile. 
You can declare a bean in a profile, but only when a profile is active, the bean shall be created by that time.
The way to activate a profile: It depends on two attributes: _spring.profiles.active_ and _spring.profiles.default_. Couple of ways to set the attributes:
* DispatcherServlet
* web.xml
* JNDI
* Environment
* JVM system attributes
* In integration tests, use @ActiveProfiles annotation

### @Conditional注解
使用场景：只有在满足特定条件的时候（在某个环境变量设置以后/某个bean声明以后）才会创建某个bean。
使用方法： @Conditional (MagicExistsCondition.class)
用到带有@Bean注解的方法上

```
@Bean
@Conditional (MagicExistsCondition.class)
public MagicBean magicBean() {
	return new MagicBean();
}
```

再创建MagicExistsCondition
```
public class MagicExistsCondition implements Condition {
    @Override
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
	    Environment env = context.getEnvironment();
		return env.containsProperty("magic");
	}
}
```
当matches()返回true时， bean被创建

### @Primary注解和@Qualifier注解
在声明bean的时候,通过将其中一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。
什么是歧义性：装配bean的时候，输入参数是个接口。任何实现了接口的类都可以在装配bean的时候作为候选人。如果不指定某个类，spring会报错。primary注解就是用来作指定的。
但是如果标了多个primary bean，依然无法工作。在这样的情况下，使用Qualifier注解。


### @Scope注解
给bean指定所需的作用域。
额外知识点：proxyMode。举例：bean A 注入到 bean B中。A的作用域是会话，B的作用域是单例。当B加载的时候A还没创建，spring此时会注入A的代理。如果A是接口，Spring创建一个代理类实现接口。如果A是个class，spring使用CGLib创建目标类的代理。

## 作用域
Spring定义了多种作用域,可以基于这些作用域创建bean,包括:
* 单例(Singleton):在整个应用中,只创建bean的一个实例。
* 原型(Prototype):每次注入或者通过Spring应用上下文获取的时候,都会创建一个新的bean实例。
* 会话(Session):在Web应用中,为每个会话创建一个bean实例。
* 请求(Rquest):在Web应用中,为每个请求创建一个bean实例。

## 运行时值注入
避免hardcode，在运行时将值注入到bean中。spring提供了两种运行时求值的方式：
* Property placeholder ${ ... }
* Spring expression language #{ T(System).currentTimeMillis()}

# Spring boot

# Java Message Service

# JVM

# Jersey + Guice + Jackson + Jetty

# Google platform & AWS

# Big Data
