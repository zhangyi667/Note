---
title: 学习导图 
tags: Java Framework
grammar_cjkRuby: true
---

# Java 基础

# HTTP协议

# Spring MVC
## Three ways to config Spring containers
* load beans in xml files
* load beans in java files
* auto-load system

## 注解
### @Component注解。
这个简单的注解表明该类会作为组件类,并告知Spring要为这个类创建bean。没有必要显式配置SgtPeppersbean,因为这个类使用了@Component注解,所以Spring会为你把事情处理妥当。

### @ComponentScan注解
这个注解能够在Spring中启用组件扫描。(如果没有其他配置的话,@ComponentScan默认会扫描与配置类相同的包。)Spring将会扫描这个包以及这个包下的所有子包,查找带有@Component注解的类并且
会在Spring中自动为其创建一个bean。之所以用这个注解，是因为这个注解默认不打开

### @ContextConfiguration(classes=SomeClass.classs)注解
Enables config loading in SomeClass, which is a java config.

### @Profile注解
Profile annotation is the feature that Spring provides for user to create certain beans according to environment.
In java config, you can use this annotation to say whether a bean belongs to a profile. 
You can declare a bean in a profile, but only when a profile is active, the bean shall be created by that time.
The way to activate a profile: It depends on two attributes: _spring.profiles.active_ and _spring.profiles.default_. Couple of ways to set the attributes:
* DispatcherServlet
* web.xml
* JNDI
* Environment
* JVM system attributes
* In integration tests, use @ActiveProfiles annotation

### @Conditional注解
使用场景：只有在满足特定条件的时候（在某个环境变量设置以后/某个bean声明以后）才会创建某个bean。
使用方法： @Conditional (MagicExistsCondition.class)
用到带有@Bean注解的方法上

```
@Bean
@Conditional (MagicExistsCondition.class)
public MagicBean magicBean() {
	return new MagicBean();
}
```

再创建MagicExistsCondition
```
public class MagicExistsCondition implements Condition {
    @Override
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
	    Environment env = context.getEnvironment();
		return env.containsProperty("magic");
	}
}
```
当matches()返回true时， bean被创建

### @Primary注解和@Qualifier注解
在声明bean的时候,通过将其中一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。
什么是歧义性：装配bean的时候，输入参数是个接口。任何实现了接口的类都可以在装配bean的时候作为候选人。如果不指定某个类，spring会报错。primary注解就是用来作指定的。
但是如果标了多个primary bean，依然无法工作。在这样的情况下，使用Qualifier注解。


### @Scope注解
给bean指定所需的作用域。
额外知识点：proxyMode。举例：bean A 注入到 bean B中。A的作用域是会话，B的作用域是单例。当B加载的时候A还没创建，spring此时会注入A的代理。如果A是接口，Spring创建一个代理类实现接口。如果A是个class，spring使用CGLib创建目标类的代理。

### 和AOP有关的注解
* @Aspect
#### Spring使用AspectJ注解来声明通知方法
* @Before
* @AfterReturning
* @AfterThrowing
* @Around


* @Pointcut @Pointcut注解能够在一个@AspectJ切面内定义可重用的切点。为了提高写代码效率。

### @DeclareParents: @DeclareParents注解由三部分组成:
* value属性指定了哪种类型的bean要引入该接口。在本例中,也就是所有实现Performance的类型。(标记符后面的加号表示是Performance的所有子类型,而不是Performance本身。)
* defaultImpl属性指定了为引入功能提供实现的类。在这里,我们指定的是DefaultEncoreable提供实现。
* @DeclareParents注解所标注的静态属性指明了要引入了接口。在这里,我们所引入的是Encoreable接口。

## 作用域
Spring定义了多种作用域,可以基于这些作用域创建bean,包括:
* 单例(Singleton):在整个应用中,只创建bean的一个实例。
* 原型(Prototype):每次注入或者通过Spring应用上下文获取的时候,都会创建一个新的bean实例。
* 会话(Session):在Web应用中,为每个会话创建一个bean实例。
* 请求(Rquest):在Web应用中,为每个请求创建一个bean实例。

## 运行时值注入
避免hardcode，在运行时将值注入到bean中。spring提供了两种运行时求值的方式：
* Property placeholder ${ ... }
* Spring expression language #{ T(System).currentTimeMillis()}

## AOP
jargons: advice, pointcut, join point
### Spring切面可以应用5种类型的通知:
* 前置通知(Before):在目标方法被调用之前调用通知功能;
* 后置通知(After):在目标方法完成之后调用通知,此时不会关心方法的输出是什么;
* 返回通知(After-returning):在目标方法成功执行之后调用通知;
* 异常通知(After-throwing):在目标方法抛出异常后调用通知;
* 环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为

### 织入(Weaving)
织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入:
* 编译期:切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。
* 类加载期:切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入(load-time weaving,LTW)就支持以这种方式织入切面。
* 运行期:切面在应用运行的某个时刻被织入。一般情况下,在织入切面时,AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。


# Spring boot

# Java Message Service
## RabbitMQ
### concepts need to know



# JVM

# Jersey + Guice + Jackson + Jetty

# Google platform & AWS

# Big Data
