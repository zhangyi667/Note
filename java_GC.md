---
title: 学习导图 
tags: Java Framework
grammar_cjkRuby: true
---

# Java GC
## 文章涉及到以下话题
	* 那些内存需要回收？
	* 什么时候回收？ 
	* 如何回收？
	* why is this so complex

* One has to know the structure of JVM before figuring out GC
	* Java堆内存一般可以分为新生代、老年代和永久代三个模块
		* 新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。
			* 一个eden区和两个survivor(survivor0，survivor1)区
			* 当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。
			* 如果老年代也满了，新生代、老年代都进行回收(FullGC)。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。
		* 老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。
			* 当老年代满时会触发Major GC(Full GC)
			* 老年代对象存活时间比较长，因此FullGC发生的频率比较低。
		* 永久代主要用于存放静态文件，如Java类、方法等。
			* 永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。
	* 垃圾回收有两种类型，Minor GC 和 Full GC。

* 垃圾回收机制的意义 -> 给对象分配内存 回收分配给对象的内存
	* 文章涉及到以下话题
		* 那些内存需要回收？(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)

		* 什么时候回收？ （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）
		* 如何回收？(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)
		* why is this so complex -> JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。Use different gc algo to make 系统 高吞吐 、低停顿

* 如何确定一个对象是否可以被回收？
	* 引用计数算法：通过判断对象的引用数量来决定对象是否可以被回收
		* it is 早期策略
		* Desc:
			* 堆中的每个对象实例都有一个引用计数 -> 一个对象被创建, 且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1
			* 任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1. 当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1
			* 当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。
			* 任何引用计数为0的对象实例可以被当作垃圾收集
		* good point: fast. 并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利
		* weakpoint: 很难解决对象之间相互循环引用的问题. 引用计数器都不为 0，那么垃圾收集器就永远不会回收

	* 可达性分析算法：通过判断对象的引用链是否可达来决定对象是否可以被回收
		* Desc: From GC Roots top-to-bottom search(Reference Chain)
		* 当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的
		* 在Java中，可作为 GC Root 的对象包括以下几种
			* 虚拟机栈(栈帧中的局部变量表)中引用的对象；
			* 方法区中类静态属性引用的对象；
			* 方法区中常量引用的对象；
			* 本地方法栈中Native方法引用的对象；

* 垃圾收集算法
	* 标记清除算法
		* desc: 扫描，标记，回收
		* weakPoint:
			* 效率问题：标记和清除两个过程的效率都不高;
			* 空间问题：内存碎片 -> 以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
	* 复制算法
		* desc: 将可用内存按容量划分为大小相等的两块 -> 使用, 复制, 清理
		* 适用于对象存活率低的场景(新生代)
		* 内存分配时也就不用考虑内存碎片等复杂情况, 实现简单，运行高效
		* 现在商用的虚拟机都采用这种算法来回收新生代。 (HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1)
		* 在对象存活率较高时就要进行较多的复制操作，效率将会变低, 在老年代一般不能直接选用这种算法
	* 标记整理算法
		* desc 扫描，标记, 让所有存活的对象都向一端移动, 直接清理掉端边界以外的内存(类似于磁盘整理的过程)
		* 不会产生内存碎片
		* 适用于对象存活率高的场景（老年代）
	* 分代收集算法
		* desc: 不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。
		* 把标记整理算法和复制算法结合用

* 垃圾收集器
	* Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
	* Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
	* ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
	* Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)* ，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
	* Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
	* CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：  老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
	* G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器 released on JDK 1.7
		* G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。
		* G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

* 内存分配与回收策略
	* 对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。当Survivor空间不够用时，需要依赖老年代进行分配担保。
	* 大对象直接进入老年代。(很长的字符串以及数组)
	* 长期存活的对象将进z老年代。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。
	* 动态对象年龄判定。 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。(In order to fit the different memory)
* Java中的内存泄露问题
	## 在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度。
	*  诸如 HashMap、Vector 等集合类的静态使用最容易出现内存泄露，因为这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。
	* 各种资源连接包括数据库连接、网络连接、IO连接等没有显式调用close关闭，不被GC回收导致内存泄露。
	* 监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。
* 知识点补充
	* 引用
	history: before 1.2, 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用. After 1.2, Java对引用的概念进行了扩充, to make it 当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。
		* 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类引用。 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
		* 软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。
		* 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
		* 虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。
	* 方法区的回收 目标:对常量池的回收 和 对类型的卸载
		* what will be 回收 -> 废弃常量, “无用的类”
		* 回收废弃常量: in 内存回收, 没有任何String对象引用常量池中的some常量，也没有其他地方引用了这个字面量, then 回收 as 废弃常量
		* 回收“无用的类”: 类需要同时满足下面3个条件才能算是“无用的类”. JVM 回收(卸载) such class when it think it's necessary.
			* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
			* 加载该类的ClassLoader已经被回收；
			* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

* 更多
	what changed in java 1.8
	* PermGen is replaced with Metaspace in Oracle/Sun JDK8, which is similar. Only different is that Metaspace can expand at runtime.The JDK 8 HotSpot JVM is now using native memory for the representation of class metadata,similar to the Oracle JRockit and IBM JVM's.

* As summary
	* 那些内存需要回收？(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)
	* 什么时候回收？ （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）
	* 如何回收？(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)
	* why is this so complex -> JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。Use different gc algo to make 系统 高吞吐 、低停顿